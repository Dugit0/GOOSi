\subsection{DOP 7 - Язык Python как мультипарадигмальный язык программирования. Python как интерпретатор. Объектная модель Python}

\textbf{Парадигмы ЯП Python}

ЯП Python может выступать в виде мультипарадигмального языка программирования. Основные парадигмы, которые поддерживает Python: \textbf{Императивное} программирование, \textbf{ООП} и \textbf{Функциональное} программирование.

\textbf{Императивное программирование} — это стиль программирования, в котором код описывает последовательность шагов, которые компьютер должен выполнить для достижения результата. В Python этот стиль широко используется благодаря своей простоте и понятности. Императивное программирование фокусируется на изменении состояния программы через присваивание значений переменным и выполнение команд в определенном порядке. Императивное программирование управляет потоком выполнения программы через условия, циклы и т.д.

\begin{verbatim}
>>> from itertools import count
>>> for c, num in zip('Hello, world', count()):
...     print(' '*num + c)
...
H
 e
  l
   l
    o
     ,
       w
        o
         r
          l
           d
\end{verbatim}

\textbf{Объектно-ориентированное программирование (ООП)} — это парадигма, в которой данные и методы, работающие с этими данными, объединяются в объекты. Python поддерживает ООП, что позволяет создавать сложные и масштабируемые приложения. ООП помогает организовать код в виде классов и объектов, что делает его более структурированным и легким для понимания.

\textbf{Основные концепции ООП}:
\begin{itemize}
    \item \textbf{Классы и объекты}: Класс — это шаблон, по которому создаются объекты. Объект — это экземпляр класса.
    \item \textbf{Наследование}: Один класс может наследовать свойства и методы другого класса.
    \item \textbf{Инкапсуляция}: Скрытие внутренней реализации объекта от внешнего мира.
    \item \textbf{Полиморфизм}: Способность объектов разных классов обрабатывать данные по-разному.
\end{itemize}

ООП также позволяет создавать более сложные структуры данных и взаимодействия между объектами. Например, можно создать систему управления библиотекой, где книги и читатели являются объектами, а методы классов позволяют добавлять книги, регистрировать читателей и выдавать книги.

\begin{verbatim}
class Book:
    def __init__(self, title, author):
        self.title = title
        self.author = author
        self.is_checked_out = False

    def check_out(self):
        if not self.is_checked_out:
            self.is_checked_out = True
            return f"{self.title} has been checked out."
        else:
            return f"{self.title} is already checked out."

    def return_book(self):
        if self.is_checked_out:
            self.is_checked_out = False
            return f"{self.title} has been returned."
        else:
            return f"{self.title} was not checked out."

class Library:
    def __init__(self):
        self.books = []

    def add_book(self, book):
        self.books.append(book)
        return f"{book.title} by {book.author} added to the library."

    def list_books(self):
        return [book.title for book in self.books]

library = Library()
book1 = Book("1984", "George Orwell")
book2 = Book("To Kill a Mockingbird", "Harper Lee")

print(library.add_book(book1))
print(library.add_book(book2))
print(library.list_books())
print(book1.check_out())
print(book1.return_book())
\end{verbatim}

\begin{verbatim}
1984 by George Orwell added to the library.
To Kill a Mockingbird by Harper Lee added to the library.
['1984', 'To Kill a Mockingbird']
1984 has been checked out.
1984 has been returned.

[Program finished]
\end{verbatim}

\textbf{Функциональное программирование} — это парадигма, в которой основное внимание уделяется использованию функций и избеганию изменения состояния. Python поддерживает функциональное программирование через функции первого класса, лямбда-выражения и функции высшего порядка. Функциональное программирование делает акцент на использование чистых функций, которые не имеют побочных эффектов и всегда возвращают один и тот же результат для одних и тех же входных данных.

\textbf{Основные концепции функционального программирования}:
\begin{itemize}
    \item \textbf{Функции первого класса}: Функции могут быть переданы как аргументы другим функциям
    \item \textbf{Функции высшего порядка}: Функции, которые принимают другие функции в качестве аргументов или возвращают функции
    \item \textbf{Чистые функции}: Функции, которые не имеют побочных эффектов и всегда возвращают один и тот же результат для одних и тех же входных данных
\end{itemize}

Функциональное программирование также включает использование функций высшего порядка, таких как `filter` и `reduce`. Например, функция `filter` позволяет отфильтровать элементы списка на основе заданного условия.

\begin{verbatim}
numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
evens = list(filter(lambda x: x % 2 == 0, numbers))
print(evens)

from functools import reduce

numbers = [1, 2, 3, 4, 5]
product = reduce(lambda x, y: x * y, numbers)
print(product)
\end{verbatim}

\begin{verbatim}
[2, 4, 6, 8, 10]
120

[Program finished]
\end{verbatim}

\textbf{Выбор парадигмы}:
\begin{itemize}
    \item \textbf{Императивное программирование} подходит для простых и небольших скриптов. Если задача не требует сложной структуры и легко решается последовательными шагами, императивное программирование может быть лучшим выбором.
    \item \textbf{Объектно-ориентированное программирование} лучше использовать для больших и сложных приложений, требующих хорошей структуры и масштабируемости. ООП позволяет организовать код в виде классов и объектов, что делает его более структурированным и легким для понимания.
    \item \textbf{Функциональное программирование} полезно для задач, требующих высокой степени абстракции и работы с данными. Функциональное программирование может быть особенно полезно для задач, связанных с обработкой данных и математическими вычислениями.
\end{itemize}

Python предоставляет гибкость для использования различных парадигм, что делает его мощным инструментом для решения самых разнообразных задач.


\textbf{Python как интерпретатор}

Поскольку Python это интерпретатор, это накладывает некоторое количество особенностей и, в первую очередь, это \textbf{динамическое построение объектов}. Статическая типизация в Python тоже существует, но в виде отдельного проекта MyPy, в целом, оторванного от основного ЯП. Динамическая типизация позволяет сильно уменьшить и упросить построение программ.

Ещё одна особенность Python - \textbf{Утиная типизация}. Если опустить всю формальность, утиная типизация подразумевает проведение некоторых операций над объектами, имеющими соответствующие методы вне зависимости от непосредственных типов объектов. Условное "сложение" двух объектов будет работать, если у них есть соответствующий метод `__add__`, вызываемый интерпретатором при встрече символа `+`, вне зависимости от типов данных объектов.

При этом в Python используется \textbf{строгая типизация} - в ЯП нет никакой функциональности относительно преобразований объектов. Если в условном С++ при выполнении некоторой функции проверяется не только полное соответствие, но и неуоторые преобразования типов для выбора подходящей функции (при перегрузках функций в понимании С++, например), логика `Python` прямая: Если с заданными типами существует функция, она срабатывает. Если нет - не срабатывает.

При работе с объектами в Python используются \textbf{ссылки}, которые обращаются к объектам в памяти. Поэтому под одним именем переменной можно в процессе программы работать с данными разных типов.

\textbf{Объектная модель Python}

Весь Python представляет из себя множество пространств имён, наполненных объектами, которые, в свою очередь, тоже в некотором смысле представляют из себя пространства имён (все объекты наполнены полями и методами, которые тоже являются объектами; получается бесконечная вложенность пространств имён).

Поскольку класс это пространство имён, его экземпляр это тоже пространство имён, "унаследованное" от классового. Поэтому мы можем создавать и удалять поля для класса (и это будет видно в объекте), а можем чисто в объекте

\begin{verbatim}
>>> class C:
...     pass
...
>>> dir(C)
['__class__', '__delattr__', '__dict__', '__dir__', ...]
>>> c = C()
>>> dir(c)
['__class__', '__delattr__', '__dict__', '__dir__', ...]

>>> C.qq = 100500
>>> c.qq
100500

>>> c.asdf = 42
>>> C.asdf
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
AttributeError: type object 'C' has no attribute 'asdf'
\end{verbatim}

Работа с полями класса и экземпляра похожа на взаимоотношение между глобальными и локальными переменными: в экземпляре будет поле из класса с его значением, при этом мы можем в экземпляре его поменять, и создастся новое локальное поле экземпляра, при этом у класса ничего не поменяется.

\begin{verbatim}
>>> class C:
...     qq = 100500
...
>>> c = C()
>>> dir(c)
['__class__', '__delattr__', '__dict__', ..., 'qq']
>>> c.qq
100500
>>> c.qq = 42
>>> dir(c)
['__class__', '__delattr__', '__dict__', ..., 'qq']
>>> C.qq
100500
\end{verbatim}
